# -*- coding: utf-8 -*-
"""GANs.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bzEu5AhopyG40Y_RXZ0gWiFokgKVG65V
"""

# tensorflow create Deep Learning models
import tensorflow as tf

tf.__version__

#find the files and folders whose names follow a specific pattern
import glob
#provides an easy interface to read and write a wide range of image data
import imageio
#help to plot graph
import matplotlib.pyplot as plt
#deal with list and arrays
import numpy as np
#able to interact with the Operating system of a computer and carry out OS related tasks
import os
#Python Imaging Library which provides the python interpreter with image editing capabilities.
import PIL
#Layers are the basic building blocks of neural networks in Keras
from tensorflow.keras import layers
#number of seconds passed since epoch
import time
#use to display data
from IPython import display

"""**Load and prepare the dataset**
We will use the MNIST dataset to train the generator and the discriminator. The generator will generate handwritten digits resembling the MNIST data.



"""



#transfering the dataset to the data frame , yh tuples hain
(train_images, train_labels), (test_images,test_labels) = tf.keras.datasets.mnist.load_data()

train_images[0]

# Adjusting image size and Normalizes the images to [-1, 1]
train_images = train_images.reshape(train_images.shape[0], 28, 28, 1).astype('float32')
#setting image pixels between [-1 to 1] ...its mandatory for better training
train_images = (train_images - 127.5) / 127.5  
train_images[6]

#time given for processing data
BUFFER_SIZE = 60000
#sample of data in one iteration
BATCH_SIZE = 256

# Batch and shuffle the data
train_dataset = tf.data.Dataset.from_tensor_slices(train_images).shuffle(BUFFER_SIZE).batch(BATCH_SIZE)

"""**The Generator**
The generator uses tf.keras.layers.Conv2DTranspose (upsampling) layers to produce an image from a seed (random noise). Start with a Dense layer that takes this seed as input, then upsample several times until you reach the desired image size of 28x28x1. Notice the tf.keras.layers.LeakyReLU activation for each layer, except the output layer which uses tanh.

Generator is build on the same pattern as discriminator but in reverse manner
"""

def make_generator_model():
    #linear stack of layers
    model = tf.keras.Sequential()
    #Dense layer is the regular deeply connected neural network layer, bias false emit model manupulations/ value use for model optimization
    model.add(layers.Dense(7*7*256, use_bias=False, input_shape=(100,)))
    #Standardize and normalize the input given to each layer in deep neural networks
    model.add(layers.BatchNormalization())
    #ensure that the output of everylayers is non negative number
    model.add(layers.LeakyReLU())
    #Adjusting nodes in every layer (batch_size, height, width, kernels)
    model.add(layers.Reshape((7, 7, 256)))
    # Note: None is the batch size
    assert model.output_shape == (None, 7, 7, 256)  
    #remove noise, or reconstruct images
    model.add(layers.Conv2DTranspose(128, (5, 5), strides=(1, 1), padding='same', use_bias=False))
    assert model.output_shape == (None, 7, 7, 128)
    model.add(layers.BatchNormalization())
    model.add(layers.LeakyReLU())
    model.add(layers.Conv2DTranspose(64, (5, 5), strides=(2, 2), padding='same', use_bias=False))
    assert model.output_shape == (None, 14, 14, 64)
    model.add(layers.BatchNormalization())
    model.add(layers.LeakyReLU())
    #The function takes any real value as input and outputs values in the range -1 to 1.
    model.add(layers.Conv2DTranspose(1, (5, 5), strides=(2, 2), padding='same', use_bias=False, activation='tanh'))
    assert model.output_shape == (None, 28, 28, 1)
    return model

"""Use the (as yet untrained) generator to create an image."""

#function call
generator = make_generator_model()
#noise vector assigned to noise
noise = tf.random.normal([1, 100])
#image generation from untrained generator
generated_image = generator(noise, training=False)
#display fake image generated by untrained generator
plt.imshow(generated_image[0, :, :, 0], cmap='gray')

"""**The** **Discriminator**
The discriminator is a CNN-based image classifier.
"""

def make_discriminator_model():
    model = tf.keras.Sequential()
    #64 filters each and 5 size of kernel
    model.add(layers.Conv2D(64, (5, 5), strides=(2, 2), padding='same',
                                     input_shape=[28, 28, 1]))
    model.add(layers.LeakyReLU())
    # prevent overfitting
    model.add(layers.Dropout(0.3))

    model.add(layers.Conv2D(128, (5, 5), strides=(2, 2), padding='same'))
    model.add(layers.LeakyReLU())
    model.add(layers.Dropout(0.3))

    #optional argument and it is used to preserve weight ordering when switching from one data format to another data format.
    model.add(layers.Flatten())
    #it should have a single node in the output layer to predict whether the output is real or fake
    model.add(layers.Dense(1))

    return model

"""Use the (as yet untrained) discriminator to classify the generated images as real or fake. The model will be trained to output positive values for real images, and negative values for fake images."""

discriminator = make_discriminator_model()
decision = discriminator(generated_image)
print (decision)

"""**Define the loss and optimizers**
Define loss functions and optimizers for both models.
"""

# This method returns a helper function to compute cross entropy loss
#from_logits=True attribute inform the loss function that the output values generated by the model are not normalized
cross_entropy = tf.keras.losses.BinaryCrossentropy(from_logits=True)

"""**Discriminator loss**
This method quantifies how well the discriminator is able to distinguish real images from fakes. It compares the discriminator's predictions on real images to an array of 1s, and the discriminator's predictions on fake (generated) images to an array of 0s.
"""

def discriminator_loss(real_output, fake_output):
    real_loss = cross_entropy(tf.ones_like(real_output), real_output)
    fake_loss = cross_entropy(tf.zeros_like(fake_output), fake_output)
    total_loss = real_loss + fake_loss
    return total_loss

"""**Generator loss**
The generator's loss quantifies how well it was able to trick the discriminator. Intuitively, if the generator is performing well, the discriminator will classify the fake images as real (or 1). Here, compare the discriminators decisions on the generated images to an array of 1s.
"""

def generator_loss(fake_output):
    return cross_entropy(tf.ones_like(fake_output), fake_output)

"""The discriminator and the generator optimizers are different since you will train two networks separately."""

#Learning Rate of 1e-4 (i.e. 0.0001)
generator_optimizer = tf.keras.optimizers.Adam(1e-4)
discriminator_optimizer = tf.keras.optimizers.Adam(1e-4)

"""**Define the training loop**"""

EPOCHS = 50
noise_dim = 100
num_examples_to_generate = 16

# You will reuse this seed overtime (so it's easier)
# to visualize progress in the animated GIF)
seed = tf.random.normal([num_examples_to_generate, noise_dim])

"""The training loop begins with generator receiving a random seed as input. That seed is used to produce an image. The discriminator is then used to classify real images (drawn from the training set) and fakes images (produced by the generator). The loss is calculated for each of these models, and the gradients are used to update the generator and discriminator."""

# Notice the use of `tf.function`
# This annotation causes the function to be "compiled".
@tf.function
def train_step(images): 
    noise = tf.random.normal([BATCH_SIZE, noise_dim])

    with tf.GradientTape() as gen_tape, tf.GradientTape() as disc_tape:
      generated_images = generator(noise, training=True)

      real_output = discriminator(images, training=True)
      fake_output = discriminator(generated_images, training=True)

      gen_loss = generator_loss(fake_output)
      disc_loss = discriminator_loss(real_output, fake_output)

    gradients_of_generator = gen_tape.gradient(gen_loss, generator.trainable_variables)
    gradients_of_discriminator = disc_tape.gradient(disc_loss, discriminator.trainable_variables)

    generator_optimizer.apply_gradients(zip(gradients_of_generator, generator.trainable_variables))
    discriminator_optimizer.apply_gradients(zip(gradients_of_discriminator, discriminator.trainable_variables))

def train(dataset, epochs):
  for epoch in range(epochs):
    start = time.time()

    for image_batch in dataset:
      train_step(image_batch)

    # Produce images for the GIF as you go
    display.clear_output(wait=True)
    generate_and_save_images(generator,
                             epoch + 1,
                             seed)

    # Save the model every 15 epochs
  

    print ('Time for epoch {} is {} sec'.format(epoch + 1, time.time()-start))

  # Generate after the final epoch
  display.clear_output(wait=True)
  generate_and_save_images(generator,
                           epochs,
                           seed)

"""**Generate and save images**"""

def generate_and_save_images(model, epoch, test_input):
  # Notice `training` is set to False.
  # This is so all layers run in inference mode (batchnorm).
  predictions = model(test_input, training=False)

  fig = plt.figure(figsize=(4, 4))

  for i in range(predictions.shape[0]):
      plt.subplot(4, 4, i+1)
      plt.imshow(predictions[i, :, :, 0] * 127.5 + 127.5, cmap='gray')
      plt.axis('off')

  plt.savefig('image_at_epoch_{:04d}.png'.format(epoch))
  plt.show()

"""**Train the model**
Call the train() method defined above to train the generator and discriminator simultaneously. Note, training GANs can be tricky. It's important that the generator and discriminator do not overpower each other (e.g., that they train at a similar rate).

At the beginning of the training, the generated images look like random noise. As training progresses, the generated digits will look increasingly real. After about 50 epochs, they resemble MNIST digits. This may take about one minute / epoch with the default settings on Colab.
"""

train(train_dataset, EPOCHS)